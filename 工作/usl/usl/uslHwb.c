
/*============================================================================*/
/*============================================================================*/
/*============================================================================*/
/*                                                                            */
/* The file was generated by parser program                                   */
/*                                                                            */
/*============================================================================*/
/*============================================================================*/
/*============================================================================*/

#include "uslHwb.h"


/*============================================================================*/
Boolean
hwb_UslCmdHeader(HwbBuf* hwb, UslCmdHeader* s) {
    if (!hwb_uint8(hwb, &s->startHigh))
        return FALSE;
    if (!hwb_uint8(hwb, &s->startLow))
        return FALSE;
    if (!hwb_uint8(hwb, &s->command))
        return FALSE;
    if (!hwb_uint8(hwb, &s->verOrErr))
        return FALSE;
    if (!hwb_uint8(hwb, &s->lengthHigh))
        return FALSE;
    if (!hwb_uint8(hwb, &s->lengthLow))
        return FALSE;
    return TRUE;
}


/*============================================================================*/
Boolean
hwb_UslSpNumber(HwbBuf* hwb, UslSpNumber* s) {
    if (!hwb_uint16(hwb, &s->firstSp))
        return FALSE;
    return TRUE;
}


/*============================================================================*/
Boolean
hwb_UslSpRange(HwbBuf* hwb, UslSpRange* s) {
    if (!hwb_uint16(hwb, &s->firstSp))
        return FALSE;
    if (!hwb_uint16(hwb, &s->nSpindles))
        return FALSE;
    return TRUE;
}


/*============================================================================*/
Boolean
hwb_UslConnect(HwbBuf* hwb, UslConnect* s) {
    if (!hwb_uint8(hwb, &s->maxVersion))
        return FALSE;
    return TRUE;
}


/*============================================================================*/
Boolean
hwb_UslConfig_1(HwbBuf* hwb, UslConfig_1* s) {
    int i;

    for (i=0; i<(USL_MAX_MA_TYPE); i++)
        if (!hwb_uint8(hwb, &s->maType[i]))
            return FALSE;
    for (i=0; i<(USL_MAX_MA_ID); i++)
        if (!hwb_uint8(hwb, &s->maId[i]))
            return FALSE;
    if (!hwb_uint16(hwb, &s->nSpindles))
        return FALSE;
    for (i=0; i<(USL_MAX_SP_MAPPING); i++)
        if (!hwb_uint8(hwb, &s->spMapping[i]))
            return FALSE;
    return TRUE;
}


/*============================================================================*/
Boolean
hwb_UslStatus_1(HwbBuf* hwb, UslStatus_1* s) {
    if (!hwb_uint8(hwb, &s->maStatus))
        return FALSE;
    if (!hwb_uint8(hwb, &s->spDataAvail))
        return FALSE;
    if (!hwb_uint32(hwb, &s->yarnCount))
        return FALSE;
    if (!hwb_uint16(hwb, &s->timeToDoff))
        return FALSE;
    if (!hwb_uint16(hwb, &s->doffNumber))
        return FALSE;
    if (!hwb_uint16(hwb, &s->temperature))
        return FALSE;
    if (!hwb_uint16(hwb, &s->humidity))
        return FALSE;
    return TRUE;
}


/*============================================================================*/
Boolean
hwb_UslAlarm_1(HwbBuf* hwb, UslAlarm_1* s) {
    int i;

    if (!hwb_uint16(hwb, &s->spNumber))
        return FALSE;
    for (i=0; i<(USL_MAX_ALARM_CODE); i++)
        if (!hwb_uint8(hwb, &s->alarmCode[i]))
            return FALSE;
    return TRUE;
}


/*============================================================================*/
Boolean
hwb_UslStatusRestore_1(HwbBuf* hwb, UslStatusRestore_1* s) {
    if (!hwb_uint16(hwb, &s->timeToDoff))
        return FALSE;
    if (!hwb_uint16(hwb, &s->doffNumber))
        return FALSE;
    return TRUE;
}



/*end of generated file*/
/*============================================================================*/